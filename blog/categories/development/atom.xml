<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: development | Ales Nosek - The Software Practitioner]]></title>
  <link href="https://alesnosek.com/blog/categories/development/atom.xml" rel="self"/>
  <link href="https://alesnosek.com/"/>
  <updated>2020-11-25T08:20:47-08:00</updated>
  <id>https://alesnosek.com/</id>
  <author>
    <name><![CDATA[Ales Nosek]]></name>

  </author>
  <generator uri="http://octopress.org/">Octopress</generator>


  <entry>
    <title type="html"><![CDATA[14 Best Practices for Developing Applications on OpenShift]]></title>
    <link href="https://alesnosek.com/blog/2020/11/24/14-best-practices-for-developing-applications-on-openshift/"/>
    <updated>2020-11-24T08:16:33-08:00</updated>
    <id>https://alesnosek.com/blog/2020/11/24/14-best-practices-for-developing-applications-on-openshift</id>
    <content type="html"><![CDATA[<p>Over the course of this year, I have been working with several development teams that started building applications on OpenShift. My goal was to provide the developers with guidance and best practices that would help them to successfully deploy their applications to production. If you are a developer that builds applications on top of OpenShift, this blog might be of interest to you.</p>

<p>The blog is published at <a href="https://www.openshift.com/blog/14-best-practices-for-developing-applications-on-openshift">openshift.com/blog</a>.</p>
]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[Local Development with OpenShift and Tilt]]></title>
    <link href="https://alesnosek.com/blog/2020/06/08/local-development-with-openshift-and-tilt/"/>
    <updated>2020-06-08T20:36:36-07:00</updated>
    <id>https://alesnosek.com/blog/2020/06/08/local-development-with-openshift-and-tilt</id>
    <content type="html"><![CDATA[<p>In this blog post, I am going to show you how to use Tilt to facilitate local OpenShift development. Tilt’s capabilities will be demonstrated in a practical example that uses buildah and CodeReady Containers. If you develop containerized applications on OpenShift, this blog post is for you.</p>

<!-- more -->


<h2>How does Tilt facilitate local development?</h2>

<p>The diagram below depicts a development workflow orchestrated by Tilt. After you execute the <code>tilt up</code> command on your development machine, Tilt will keep running while performing the following actions:</p>

<ol>
<li>Tilt watches for changes in the source code made by the developer on the local machine.</li>
<li>After a change has been detected, Tilt executes buildah to update the container image. After the build completes, the updated container image is pushed to the internal registry in CodeReady Containers.</li>
<li>Tilt watches Kubernetes manifests on the local machine and keeps them in sync with CodeReady Containers. Any changes made to the manifests are instantly applied to CodeReady Containers.</li>
<li>Tilt forwards local ports to the application pod running in CodeReady Containers. This allows the developer to conveniently access the application on localhost.</li>
</ol>


<p><img class="center" src="/images/posts/local_development_with_openshift_and_tilt_diagram.png"></p>

<p>Tilt helps the developer automate many of the manual steps made during the development of containerized applications. It speeds up the edit-compile-run loop considerably. Interested to trying it out? Follow me to the next section, where we will implement the workflow depicted in the above diagram.</p>

<h2>Using Tilt for developing a sample application</h2>

<p>In this section, we are going to use Tilt to orchestrate the development of a sample application. As I didn&rsquo;t want to reinvent the wheel by designing a custom application, I grabbed the Plain Old Static HTML example that comes with Tilt and can be found on <a href="https://github.com/tilt-dev/tilt-example-html/tree/faad605963b396b0863151802544fb01f6b414c6/0-base">GitHub</a>. This example is described in the Tilt&rsquo;s <a href="https://docs.tilt.dev/example_static_html.html">documentation</a> and you may already be familiar with it. It consists of a very simple shell script that serves a static HTML. In contrast to Tilt&rsquo;s example which leverages Docker and upstream Kubernetes, I will be using developer tools from the Red Hat&rsquo;s portfolio:</p>

<ul>
<li><a href="https://buildah.io/">buildah</a></li>
<li><a href="https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image">UBI container images</a></li>
<li><a href="https://developers.redhat.com/products/codeready-containers">CodeReady Containers</a></li>
</ul>


<p>In order to be able to use the Red Hat developer tools, I had to modify the original sample code. The sample code used in this tutorial can be found on <a href="https://github.com/noseka1/local-development-with-openshift-and-tilt">GitHub</a>. I recommend that you go ahead and briefly review it.</p>

<p>The overall setup consists of a Fedora 32 development machine where I installed buildah and CoreReady Containers (CRC) version 1.10. I installed Tilt version 0.13.4 which is the latest release of Tilt available at the time of this writing. If you plan to use Tilt along with CodeReady Containers, I recommend grabbing this or any future versions of Tilt, as this version includes a <a href="https://github.com/windmilleng/tilt/commit/7e9487816ea32ed086318ce7373c67d9febb6f36">patch</a> that makes Tilt work with CodeReady Containers without the need for further configuration. The Tilt binary can be downloaded from <a href="https://github.com/tilt-dev/tilt/releases">GitHub</a>.</p>

<p>Having the required tools in place, let&rsquo;s start by logging in into CRC and creating a new project:</p>

<pre><code>$ oc login
$ oc new-project tilt-example
</code></pre>

<p>Let&rsquo;s now focus  on configuring buildah to be able the pull and push images from the container registries. As you can see in the <a href="https://github.com/noseka1/local-development-with-openshift-and-tilt/blob/master/Dockerfile">Dockerfile</a>, our application uses the <code>registry.redhat.io/ubi8/ubi</code> container image as the base image. In order for buildah to be able to pull this image from the registry, we need to log in to this registry using the Red Hat Customer Portal credentials:</p>

<pre><code>$ buildah login registry.redhat.io
</code></pre>

<p>Next, let&rsquo;s configure buildah to be able to push images into the CRC internal registry. The CRC registry endpoint uses a self-signed certificate. Buildah will refuse to communicate with the internal registry as the certificate is signed by an unknown authority. In order for buildah to be able to push images into the internal registry, you will need to add this registry to the list of insecure registries. On your development machine, edit <code>/etc/containers/registries.conf</code> and add the CRC internal registry to the list of insecure registries.</p>

<pre><code>[registries.insecure]
registries = [ 'default-route-openshift-image-registry.apps-crc.testing' ]
</code></pre>

<p>In order for buildah to be able to push images into the CRC registry, we need to log in to this registry. For that, use the <code>oc</code> command to grab a token used for authentication against the registry:
<code>
$ oc whoami --show-token
7geTDzA6Mqa-NeXweTXtOFUJtEHocVShKl5yxtxqeB0
</code>
Log in to the registry using the authentication token:
<code>
$ buildah login \
    --username unused \
    --password 7geTDzA6Mqa-NeXweTXtOFUJtEHocVShKl5yxtxqeB0 \
    default-route-openshift-image-registry.apps-crc.testing
Login Succeeded!
</code></p>

<p>After successfully logging into the CRC internal registry, the buildah configuration is now complete. Finally, we can turn our attention to Tilt. First, let&rsquo;s review the <code>Tiltfile</code> which describes how Tilt will orchestrate our development workflow:</p>

<pre><code># push the container image to the CRC internal registry, project tilt-example
default_registry(
  'default-route-openshift-image-registry.apps-crc.testing/tilt-example',
  host_from_cluster='image-registry.openshift-image-registry.svc:5000/tilt-example')

# use buildah to build and push the container image
custom_build(
  'example-html-image',
  'buildah build-using-dockerfile --tag $EXPECTED_REF . &amp;&amp; buildah push $EXPECTED_REF',
  ['.'],
  skips_local_docker=True)

# deploy Kubernetes resource
k8s_yaml('kubernetes.yaml')

# make the application available on localhost:8000
k8s_resource('example-html', port_forwards=8000)
</code></pre>

<p>I annotated the <code>Tiltfile</code> with comments that explain the meaning of individual Tilt instructions. Ready to give it a shot? Just clone the git repository and run Tilt:</p>

<pre><code>$ git clone https://github.com/noseka1/local-development-with-openshift-and-tilt
$ cd local-development-with-openshift-and-tilt/
$ tilt up
</code></pre>

<p>After Tilt comes up, it will call buildah to pull the base image, build the application, and push the resulting image to the CRC internal registry. It will also deploy the application on Kubernetes by applying the <code>kubernetes.yaml</code> manifest referenced in the <code>Tiltfile</code>. If everything worked well, and the application pod starts up, you will see the &ldquo;Serving files on port 8000&rdquo; log message in the bottom pane:</p>

<p><img class="center" src="/images/posts/local_development_with_openshift_and_tilt.png"></p>

<p>At this point, you should be able to reach the running application on <code>localhost:8000</code>:
<code>
$ curl localhost:8000
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;body style="font-size: 30px; font-family: sans-serif; margin: 0;"&gt;
    &lt;div style="display: flex; flex-direction: column; width: 100vw; height: 100vh; align-items: center; justify-content: center;"&gt;
      &lt;img src="pets.png" style="max-width: 30vw; max-height: 30vh;"&gt;
      &lt;div&gt;Hello cats!&lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></p>

<p>To experience how Tilt facilitates the local development, change the content of the <code>index.html</code> file. After you save your changes, Tilt will instantly re-run the loop and deploy the updated application.</p>

<h2>Conclusion</h2>

<p>In this blog, we described how Tilt can facilitate the local development of containerized applications. We demonstrated Tilt&rsquo;s capabilities in a practical example that showed Tilt working along with buildah and CodeReady Containers. In this introductory article, we were able to only scratch the surface. There is much more that Tilt has to offer, including live updates that can update the application without restarting the container, and which can drastically speed up the edit-compile-run loop. I encourage you to read through <a href="https://docs.tilt.dev/">Tilt&rsquo;s documentation</a> to learn more about this tool.</p>

<p>Do you use Tilt for development on OpenShift or Kubernetes? What&rsquo;s your opinion on Tilt? I would be happy to hear about your experiences. You can leave your comments in the comment section below.</p>
]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[Open Policy Agent, Part III &mdash; Integrating with Your Application]]></title>
    <link href="https://alesnosek.com/blog/2019/12/03/open-policy-agent-part-iii-integrating-with-your-application/"/>
    <updated>2019-12-03T12:46:10-08:00</updated>
    <id>https://alesnosek.com/blog/2019/12/03/open-policy-agent-part-iii-integrating-with-your-application</id>
    <content type="html"><![CDATA[<p>In the <a href="/blog/2019/10/27/open-policy-agent-part-ii-developing-policies/">previous entry</a> to this series, we discussed developing policies with Open Policy Agent. In this final article in the series, we are going to focus on how you can integrate Open Policy Agent with your application.</p>

<!-- more -->


<h2>Integrating OPA with your application</h2>

<p>There are several options how you can integrate OPA with your application. If you happen to build your application using the Go language, you can link OPA as a library straight into your application. Otherwise, you will run OPA as a stand-alone service (daemon). If you deploy your application on Kubernetes, you can run OPA service as a side-car container along with your application services. This minimizes the communication latency between OPA and your application. It also avoids possible communication issues between OPA and your application due to network failures. If you are deploying on virtual machines, you can run one replica of the OPA service on each of your virtual machines to achieve the same benefits. In summary, deploying OPA as a side-car service or a host-local service is the recommended approach.</p>

<p><img class="center" src="/images/posts/open_policy_agent/opa_integration.png"></p>

<p>Another deployment option would be running multiple OPA services behind a load balancer. Your application and OPA services would in this case talk over the network and the communication would go through the load balancer. You would incur the cost of network latency. However, I am not sure how would the overall reliability of this approach compare to the side-car approach. OPA documentation doesn&rsquo;t really mention this option of deploying multiple OPA services behind a load balancer. However, if you are building your application as a set of Lambda functions, then this might be the way to go:</p>

<p><img class="center" src="/images/posts/open_policy_agent/opa_integration_lambda.png"></p>

<h2>Utilizing Open Policy Agent APIs</h2>

<p>Open Policy Agent comes with a whole set of APIs that you can use in order to utilize OPA to its full potential. I depicted the possible API integrations in the following diagram:</p>

<p><img class="center" src="/images/posts/open_policy_agent/opa_integration_full.png"></p>

<p>In the diagram above, the green box is your application invoking policy queries against OPA. The purple services are optional services that you can include in your architecture. These services have to be implemented by yourself and they must expose APIs that are specified by OPA. Two blue boxes depict the Prometheus monitoring server and Kubernetes. OPA can integrate with them right away. In the diagram, the direction of the arrows between services is significant. The arrows indicate which service from the pair initiates the TCP connection. In the following subsections, let&rsquo;s take a closer look at each of these OPA interfaces.</p>

<h3>Open Policy Agent REST API</h3>

<p>This is the main API provided by OPA that your application uses to manage data and policies, and to execute queries. It is well described in the OPA&rsquo;s <a href="https://www.openpolicyagent.org/docs/latest/rest-api/">REST API documentation</a>. I would like to highlight two things that I learned about the OPA REST APIs:</p>

<p>First, OPA allows you to set watches on policy queries in order for you to be notified whenever the result of the query evaluation changes. Watches utilize the HTTP long polling mechanism. For additional details, you can refer to the <a href="https://www.openpolicyagent.org/docs/latest/rest-api/#watches">Watches</a> section of the OPA&rsquo;s documentation.</p>

<p>Second, the communication between the client (i.e. your application) and the OPA service can be protected using TLS. OPA authenticates itself to the client by presenting a valid TLS certificate. Client can authenticate itself to OPA either by presenting a client TLS certificate or by presenting a security token. And guess how OPA handles API authorization? Of course, by evaluating a Rego policy that you supply. For further details on OPA&rsquo;s security settings, refer to the <a href="https://www.openpolicyagent.org/docs/latest/security/">Security</a> section of OPA&rsquo;s documentation.</p>

<h3>Optional APIs</h3>

<p>These APIs are specified by OPA  and you can opt to implement them in order to gain additional functionality and better integrate OPA into your system.</p>

<p>If you recall, in the first part of the series we imported data and policies into OPA by pushing it via the REST APIs. Pushing the data and policies into OPA is not always a feasible option. For example, if OPA is deployed as an ephemeral pod on Kubernetes, it would be difficult to ensure that the API call is made each time right after the pod has started.  How can you make OPA work in such scenarios? You can deploy a service which implements the <a href="https://www.openpolicyagent.org/docs/latest/bundles/#bundle-service-api">Bundle Service API</a> and configure OPA to periodically pull up-to-date policies and data from this service. In the simplest case, the service can be implemented as a static HTTP server that hosts the policy and data bundles. However, if your use case demands it, you can implement a service that generates policies and data for OPA on-the-fly. When pulling the policies and data, OPA checks the ETag to find out if a new version is available. The Bundle service allows you to ensure that your policies are consistent across many OPA instances and enables you to hot reload them at any time.</p>

<p>OPA can be configured using a set of static configuration files. In Kubernetes, you would likely manage these configuration files as ConfigMaps. However, OPA comes with its own mechanism to manage configuration files from a central place. You can implement the <a href="https://www.openpolicyagent.org/docs/latest/discovery/">Discovery Service API</a> to expose the configuration files as discovery bundles to OPA instances. On the startup, OPA will download its configuration from the Discovery Service.</p>

<p>OPA can send <a href="https://www.openpolicyagent.org/docs/latest/status/">status</a> updates to remote HTTP servers that implement a simple <a href="https://www.openpolicyagent.org/docs/latest/status/#status-service-api">Status Service API</a> . You will be notified whenever OPA downloads and actives a new bundle. Notifications are issued for both policy+data bundles and discovery bundles.</p>

<p>OPA can periodically report <a href="https://www.openpolicyagent.org/docs/latest/decision-logs/">decision logs</a> to remote HTTP servers that implement a <a href="https://www.openpolicyagent.org/docs/latest/decision-logs/#decision-log-service-api">Decision Log Service API</a>. The reported decision logs record all the policy decisions made by OPA. How could you make use of it? You could implement a simple Decision Log Service that would run co-located with the OPA service and that would store the decision logs into a durable storage like Kafka. And here you go, an awesome audit log was born!</p>

<h3>Health and Monitoring APIs</h3>

<p>OPA exposes a <a href="https://www.openpolicyagent.org/docs/latest/rest-api/#health-api">Health API</a> for you to periodically verify that the OPA service is operational. If you are deploying OPA on top of Kubernetes,  you can leverage the Health API to define the <a href="https://www.openpolicyagent.org/docs/latest/deployments/#readiness-and-liveness-probes">liveness and readiness probes</a>. OPA also exposes Prometheus metrics to <a href="https://www.openpolicyagent.org/docs/latest/monitoring/">monitor</a> the performance of OPA API calls. Both health and monitoring APIs can be secured the same way as the OPA REST API which we discussed before.</p>

<h2>Where to go from here?</h2>

<p>In addition to the written sources that you can find on the web, I would like to point you to a couple of excellent presentations about Open Policy Agent hosted on YouTube:</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=CDDsjMOtJ-c">Intro: Open Policy Agent - Torin Sandall, Styra (2018)</a></li>
<li><a href="https://www.youtube.com/watch?v=n94_FNhuzy4">Deep Dive: Open Policy Agent - Torin Sandall &amp; Tim Hinrichs, Styra (2019)</a></li>
</ul>


<p>If you are evaluating Open Policy Agent from the security perspective, this <a href="https://github.com/open-policy-agent/opa/blob/master/SECURITY_AUDIT.pdf">audit report</a> might be of interest to you as well.</p>

<h2>Conclusion</h2>

<p>In this article, we discussed several ways for how you can integrate Open Policy Agent with your application. We also described the set of APIs defined by OPA that you can utilize to take full advantage of Open Policy Agent.</p>

<p>Open Policy Agent is a young and fast-moving project. Despite my rather short experience with OPA, I can already recommend that you consider using Open Policy Agent in your project before spending time on implementing your own domain specific language for writing policies or coding your policies in a general-purpose programming language. OPA will keep the policies consistent across your system, will allow you to hot reload the policies at any time and will make policy decisions with very low latency for you.</p>

<p>So far, each of the open source projects came up with its own way how to implement access control. System administrators have to learn how to grant access permissions in the Apache HTTP server, Kubernetes, and fill in your favorite open source project here. It would be great if OPA&rsquo;s Rego language would become an open standard for describing access control rules across the open source ecosystem. I hope that the future will show that this is possible.</p>

<p>Regardless of what other projects decide for themselves, we are planning to utilize Open Policy Agent in the SaaS project I am involved with as a consultant. As we are moving forward,  I intend to share the experience that we gain with OPA with you in some of the future blog posts.</p>

<p>I hope that you found this blog series about Open Policy Agent helpful. If you have any questions or comments, please leave them in the comment section below. I look forward to hearing from you.</p>
]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[Open Policy Agent, Part II &mdash; Developing Policies]]></title>
    <link href="https://alesnosek.com/blog/2019/10/27/open-policy-agent-part-ii-developing-policies/"/>
    <updated>2019-10-27T20:37:08-07:00</updated>
    <id>https://alesnosek.com/blog/2019/10/27/open-policy-agent-part-ii-developing-policies</id>
    <content type="html"><![CDATA[<p>In the <a href="/blog/2019/10/08/open-policy-agent-part-i-the-introduction/">previous part</a> of the series, we explored Open Policy Agent and implemented an ACL-based access control for our application. In this entry, I am going to share with you some of the discoveries that I made while evaluating Open Policy Agent in regards to policy design and development.</p>

<!-- more -->


<h2>Notes on Policy Design</h2>

<p>After evaluating policy rules, OPA returns a result of the policy decision to your application. This result is a JSON structure. Based on your requirements, this JSON structure can contain a single member holding a <em>true</em> or <em>false</em> (authorized/not authorized) value. However, you can create policies whose evaluation results in an arbitrarily complex JSON document. For example, OPA can return a list of nodes on which Kubernetes should schedule a workload.</p>

<p>In microservice applications, OAuth 2.0 is a rather popular authorization framework used to secure service’s APIs. It typically leverages JSON Web Tokens (JWT) to convey claims. OPA comes with built-in functions that can decode the token and validate its signature and expiration time. Furthermore, your policy rules can make decisions based on the claims included in the token. Just forward the token as an input to OPA and offload the entire token processing from your application!</p>

<p>OPA makes policy decisions based on the data stored in memory. In the case of large data sets, replicating all the data in memory can be impractical. While evaluating policy rules, is OPA able to reach out to an external data store to get additional data for decision making? For example, send a query to LDAP to grab additional attributes or look up data in an SQL database? Based on my research, I think there are two possible approaches for leveraging external data sources in OPA. First, there is a built-in <a href="https://www.openpolicyagent.org/docs/latest/language-reference/#http">HTTP</a> function that can fetch data from external HTTP services during policy evaluation. Second, you can leverage Partial Evaluation as described in this <a href="https://blog.openpolicyagent.org/write-policy-in-opa-enforce-policy-in-sql-d9d24db93bf4">blog post</a>. While partially evaluating policies, OPA doesn’t return a complete policy decision but instead it returns a set of conditions. It is left to you to translate this set of conditions into a query appropriate for your data store and execute the query in order to obtain the final policy decision. Note that regardless of which approach you choose, reaching out to external data stores will have negative impact on latency and reliability of your solution. Caching data in OPA’s memory is always a better option assuming that it suits your use case.</p>

<p>If you have raw data that would be difficult to write a policy against, you can pre-process that data into a form that better suits the policy writing before importing it into OPA. Moreover, if you have multiple sources of data, e.g. data from LDAP and Active Directory, you can merge them outside of OPA and load the merged form into OPA.</p>

<p>RBAC (Role-Based Access Control) and ABAC (Attribute-Based Access Control) are two frequently used policy models. Are you wondering if you can implement them using OPA? Of course you can! Follow these two links to find sample implementations of <a href="https://www.openpolicyagent.org/docs/latest/comparison-to-other-systems/#role-based-access-control-rbac">RBAC</a> and <a href="https://www.openpolicyagent.org/docs/latest/comparison-to-other-systems/#attribute-based-access-control-abac">ABAC</a>.</p>

<p>Hierarchical group permissions are commonly found in practice, e.g. parent group permissions are a superset of child group permissions. These models can be elegantly described using recursive rules. However, at the time of this writing, OPA doesn’t support <a href="https://github.com/open-policy-agent/opa/issues/947">recursion in policies</a>.</p>

<h2>Developing policies</h2>

<p>While learning the OPA’s Rego language, I appreciated the built-in interactive shell (REPL) that I could use to write and test my policies instantly. Just type <code>opa run</code> and you are good to go. Alternatively, you can go on-line and utilize the <a href="https://play.openpolicyagent.org/">Rego Playground</a>, too.</p>

<p>If you are dealing with complex policies, how do you ensure that you implemented your policies correctly? OPA <a href="https://www.openpolicyagent.org/docs/latest/how-do-i-test-policies/">allows</a> you to write test cases which you can run against your policies. You can use data mocking and calculate test coverage. See also the command <code>opa test</code>.</p>

<p>Is the evaluation of your policies too slow? OPA comes with a <a href="https://www.openpolicyagent.org/docs/latest/how-do-i-test-policies/#profiling">profiler</a> to report on time spent on evaluating policy expressions. See also the <code>opa eval</code> command.</p>

<p>OPA comes with a formatting tool <code>opa fmt</code> to format Rego policy files. You don’t need to fight battles with other developers about how the Rego files should be formatted!</p>

<p>OPA is a relatively new project, however, additional tooling and integrations with OPA are showing up quickly. If you like to use Visual Studio Code, there is a feature-rich <a href="https://marketplace.visualstudio.com/items?itemName=tsandall.opa">VS Code plugin</a> available for you. Rego syntax highlighting is available for several other editors like VIM, <a href="https://github.com/open-policy-agent/opa/tree/master/misc/syntax/atom">Atom</a>, and <a href="https://github.com/open-policy-agent/opa/tree/master/misc/syntax/textmate">TextMate</a>.</p>

<h2>Conclusion</h2>

<p>In this blog post, I shared with you several tips and approaches for how to design policies in Open Policy Agent. In the <a href="/blog/2019/12/03/open-policy-agent-part-iii-integrating-with-your-application/">final article</a> in the series we will focus on how you can integrate Open Policy Agent with your application.</p>

<p>If you have any comments or questions, please use the comment section below. I look forward to hearing from you.</p>
]]></content>
  </entry>

  <entry>
    <title type="html"><![CDATA[Open Policy Agent, Part I &mdash; The Introduction]]></title>
    <link href="https://alesnosek.com/blog/2019/10/08/open-policy-agent-part-i-the-introduction/"/>
    <updated>2019-10-08T07:13:38-07:00</updated>
    <id>https://alesnosek.com/blog/2019/10/08/open-policy-agent-part-i-the-introduction</id>
    <content type="html"><![CDATA[<p>Recently I was looking for a way to implement access control for microservices. I needed a solution that would allow defining complex authorization rules that could be enforced across many services. After searching the web, I discovered a very promising <a href="https://www.openpolicyagent.org/">Open Policy Agent</a> project that seems to be the right tool for the job. In this series of three blog posts, I am going to introduce Open Policy Agent to you and highlight how it can help you.</p>

<!-- more -->


<h2>What is Open Policy Agent?</h2>

<p>Open Policy Agent (OPA) is a policy engine that can be used to implement fine-grained access control for your application. For example, you can use OPA to implement <a href="https://www.openpolicyagent.org/docs/latest/http-api-authorization/">authorization</a> across microservices. However, there is much more that can be accomplished with OPA. For your inspiration, there are several open-source projects that integrate with OPA to implement fine-grained access control like <a href="https://github.com/open-policy-agent/opa-docker-authz">Docker</a>, <a href="https://github.com/open-policy-agent/opa-istio-plugin">Istio</a> and <a href="https://github.com/open-policy-agent/contrib">others</a>. Furthermore, OPA as a general-purpose policy engine, can be leveraged in use cases beyond access control, for instance to make advanced pod placement decisions in <a href="https://github.com/open-policy-agent/opa-kube-scheduler">Kubernetes</a>.</p>

<p>OPA can be deployed as a standalone service along with your microservices. In order to protect your application, each request coming to a microservice must be authorized before it can be processed. To check the authorization, the microservice makes an API call to OPA to decide whether the request is authorized or not. Note that while you can offload authorization decisions from your application to OPA, your application still has to implement the enforcement of those decisions. For example, your application can ask OPA the question <em>&ldquo;Is user Alice allowed to invoke GET /protected/resource?&rdquo;</em> and if OPA answers <em>&ldquo;No&rdquo;</em>, your application has to send HTTP 403 Forbidden back to Alice.</p>

<p><img class="center" src="/images/posts/open_policy_agent/opa_basic_flow.png"></p>

<p>OPA is written in the Go language and its source code is available on <a href="https://github.com/open-policy-agent/opa">GitHub</a> under the Apache License 2.0. The Open Policy Agent project is hosted by <a href="https://www.cncf.io/">CNCF</a> as an incubating project.</p>

<h2>Making policy decisions</h2>

<p>In this section, I am going to explain how OPA works. Don&rsquo;t worry if everything is not clear to you right away. In the following section, we are going to work through a practical example which will help clarify the details.</p>

<p>What does it take for OPA to make a policy decision? In OPA, there are three inputs into the decision-making process:</p>

<ol>
<li><strong>Data</strong> is a set of facts about the outside world that OPA refers to while making a decision. For example, when controlling access based on the access control list, the data would be a list of users along with the permissions they were granted. Another example: when deciding where to place the next pod on the Kubernetes cluster, the data would be a list of Kubernetes nodes and their currently available capacity. Note that data may change over time and OPA caches its latest state in memory. The data must be provided to OPA in the JSON format.</li>
<li><strong>Query Input</strong> triggers the decision computation. It specifies the question that OPA should decide upon. The query input must be formatted as JSON. For instance, for the question <em>&ldquo;Is user Alice allowed to invoke GET /protected/resource?&rdquo;</em> the query input would contain parameters: <em>Alice</em>, <em>GET</em>, and <em>/protected/resource</em>.</li>
<li><strong>Policy</strong> specifies the computational logic that for the given <em>data</em> and <em>query input</em> yields a policy decision aka query result. The computational logic is described as a set of policy rules in the OPA&rsquo;s custom policy language called <a href="https://www.openpolicyagent.org/docs/latest/how-do-i-write-policies/">Rego</a>. Note that OPA doesn&rsquo;t come with any pre-defined policies. OPA is a policy engine that is able to interpret a policy, however, in order to make use of it you have to create a policy yourself and provide it to OPA.</li>
</ol>


<p><img class="center" src="/images/posts/open_policy_agent/opa_policy_decision.png"></p>

<p>In order to make a policy decision, all three inputs (data, query input, and the policy) are fed into the Policy Engine. The Policy Engine interprets the rules included in the policy and based on the data and the query input makes a policy decision. The policy decision generated by the Policy Engine is a JSON document.</p>

<p>That is how OPA works from a high-level perspective. In the next section, we will dive into a practical example.</p>

<h2>Hands-on tutorial</h2>

<p>This section is a hands-on tutorial where I will walk you through an example of working with OPA. Although, all sorts of access control models can be implemented using OPA, the goal of this exercise is to implement access control using an Access Control List (ACL). So, let&rsquo;s get started!</p>

<h3>Creating data</h3>

<p>Access control list specifies which users have access to the application as well as what operations they are allowed to invoke. For the purposes of this tutorial, I came up with a simple ACL definition:
<code>
{
  "alice": [
    "read",
    "write"
  ],
  "bob": [
    "read"
  ]
}
</code>
According to this ACL, a user named <code>alice</code> was granted <code>read</code> and <code>write</code> access to the application. In addition, a user named <code>bob</code> was given <code>read</code> access. No other users were given any access to the application. For now, you can save this ACL definition as a file called <code>myapi-acl.json</code>.</p>

<p>Note that later on we are going to inject this access control list as <em>data</em> into OPA to allow it to make policy decisions based on this list. How did we know what the structure of the ACL document looks like? As a matter of fact, OPA doesn&rsquo;t prescribe how you should structure your data. It only requires the data to be in a JSON format. The recommendation is to structure your data in a way that makes it easy to write policy rules against it. I followed this recommendation and the above access control list is what I came up with.</p>

<h3>Defining query input</h3>

<p>Next, we are going to define a structure of the <em>query input</em>. On each access to our application, we are going to ask OPA whether the given access is authorized or not. To answer that question, OPA needs to know the name of the user that is trying to access the application and the operation that the user is trying to invoke. Here is a sample query input that conveys the two query arguments to OPA :</p>

<pre><code>{
  "input": {
    "user": "alice",
    "operation": "write"
  }
}
</code></pre>

<p>You can interpret this query input as the question: &ldquo;Is user <em>alice</em> allowed <em>write</em> access to the application?&rdquo;. Note that it&rsquo;s up to you how you structure your query input. OPA&rsquo;s only requirement is for the input to be in the JSON format.</p>

<h3>Writing Rego policy</h3>

<p>After we decided how our data and the query input look like, we can create a <em>policy</em> that implements the ACL semantics. Using the Rego language, let&rsquo;s create a policy with two rules <code>allow</code> and <code>whocan</code>:</p>

<pre><code>package myapi.policy

import data.myapi.acl
import input

default allow = false

allow {
        access = acl[input.user]
        access[_] == input.access
}

whocan[user] {
        access = acl[user]
        access[_] == input.access
}
</code></pre>

<p>The <code>allow</code>  rule checks whether the user is allowed access according to the ACL. It instructs the policy engine to first look up the user&rsquo;s record in ACL and then to check whether the operation the user is trying to invoke is included on user&rsquo;s permission list. Only if there is an ACL record for the given user and the user was granted given access permission, the allow rule results to <code>true</code>. Otherwise it results to <code>false</code>.</p>

<p>The second rule in our policy is the <code>whocan</code> rule. This rule takes the operation as the input argument. For the given operation, <code>whocan</code> rule returns a list of all users that are allowed to invoke the given operation.</p>

<p>You can save the above policy as a file called <code>myapi-policy.rego</code>. We are going to upload it into OPA in just a moment. At this point, both the ACL file <code>myapi-acl.json</code> we created earlier and the policy file  <code>myapi-policy.rego</code> are sitting in our working directory. It&rsquo;s now time to put OPA to work!</p>

<h3>Starting up Open Policy Agent service</h3>

<p>You can grab the OPA binary for your  platform (Linux, MacOS, or Windows) from <a href="https://github.com/open-policy-agent/opa/releases">GitHub</a>. After downloading the binary, start the OPA service by issuing the command:</p>

<pre><code>$ opa run --server
</code></pre>

<p>OPA service is now up and listening on port <code>8181</code>. Next, we are going to upload the ACL file and the policy file into OPA. Note that OPA stores both the data and policies in memory and so if you restart the OPA service, you will have to reload both of the files.</p>

<p><img class="center" src="/images/posts/open_policy_agent/opa_upload_policy_and_data.png"></p>

<p>First, upload the ACL file <code>myapi-acl.json</code> into OPA using the following <code>curl</code> command:</p>

<pre><code>$ curl -X PUT http://localhost:8181/v1/data/myapi/acl --data-binary @myapi-acl.json
</code></pre>

<p>Next, upload the policy file <code>myapi-policy.rego</code> into OPA by issuing:
<code>
$ curl -X PUT http://localhost:8181/v1/policies/myapi --data-binary @myapi-policy.rego
</code></p>

<h3>Invoking policy queries</h3>

<p>Finally, if everything went well, we are now ready to issue our first  query.</p>

<p><img class="center" src="/images/posts/open_policy_agent/opa_query_policy.png"></p>

<p>Let&rsquo;s ask OPA whether the user <code>alice</code> can invoke a <code>write</code> operation on our application:
<code>
$ curl -X POST http://localhost:8181/v1/data/myapi/policy/allow \
--data-binary '{ "input": { "user": "alice", "access": "write" } }' \
| jq
{
  "result": true
}
</code></p>

<p>The query result returned by OPA says that the user <code>alice</code> is authorized for writing. Our application would now proceed with executing the write operation. And what about <code>bob</code>? Is user <code>bob</code> allowed to write?</p>

<pre><code>$ curl -X POST http://localhost:8181/v1/data/myapi/policy/allow \
--data-binary '{ "input": { "user": "bob", "access": "write" } }' \
| jq
{
  "result": false
}
</code></pre>

<p>The query result says it clearly. User <code>bob</code> is denied <code>write</code> access. Our application would return HTTP 403 Forbidden to <code>bob</code> at this point.</p>

<p>From what we have seen so far, a query result can be a simple <code>true</code> or <code>false</code> value. However, this is not a limitation that OPA would impose. OPA allows you to write policy rules that can yield an arbitrarily complex JSON structure. For example, the <code>whocan</code> rule that we defined in our policy, returns a JSON list.</p>

<p>Let&rsquo;s give it a try and ask OPA to return a list of users that were granted the <code>read</code> permission:</p>

<pre><code>$ curl -X POST http://localhost:8181/v1/data/myapi/policy/whocan \
--data-binary '{ "input": { "access": "read" } }' \
| jq
{
  "result": [
    "alice",
    "bob"
  ]
}
</code></pre>

<h2>Conclusion</h2>

<p>In this article, we took an initial look at Open Policy Agent. After discussing how OPA works, we went through an example of implementing an Access Control List policy. In the <a href="/blog/2019/10/27/open-policy-agent-part-ii-developing-policies/">next entry</a> to this series, we are going to dive deeper into developing policies with OPA.</p>

<p>I hope that you found this article useful. If you have any questions or comments, please add them to the comment section below. I look forward to hearing from you.</p>
]]></content>
  </entry>

</feed>
